\chapter{基于国产AI处理器的Top-k算子设计实现}
传统 top-k 查询算法主要是基于通用处理器进行设计和实现的，
虽然基于通用处理器设计的算法实现相对简单，
但是随着待处理数据规模的不断增大，通用处理器已经无法满足数据处理对于算力的需求。
而深度学习处理器专门针对深度学习神经网络处理海量数据处理而设计，
为深度学习网络模型进行数据处理提供了强大算力，为各类深度学习算法实现加速，
而这一特性是传统Top-k查询所缺失的。因此设计实现基于深度学习处理器的 
Top-k 算法显得尤为重要。尽管在国产AI处理器架构上已经实现了基于冒泡排序的实现，
但是当数据规模较大的时候，其性能仍然存在一定的不足。
因此本文结合国产 AI 处理器的异构计算特点，
根据radix-select算法设计了Top-k算子。
具体而言，首先概述了Top-K算法在异构架构下的计算流程。随后，
深入探讨了主机端（CPU）在数据预处理阶段的职责与关键操作。
最后，针对国产 AI 处理器的硬件设计，
详尽阐述了设备端 Top-k 查询算法的实现策略。


\section{国产AI处理器Top-k算子计算流程}
在现代计算领域，随着大数据的迅速发展和人工智能技术的不断进步，
基于国产 AI 芯片的 Top-k 算子计算流程已经逐渐发展为一种典型的异构计算模式，
通常需要主机端（如 CPU）和设备端（如 AI 处理器）协同工作。
整个计算流程可以分为三个主要阶段：数据准备和预处理阶段、数据传输阶段和核心计算阶段。

1. 数据准备和预处理阶段（主机端执行）

在整个Top-k算子计算过程中，数据准备和预处理阶段是非常关键的部分，通常由主机端负责。
在这一阶段，主机端（通常是 CPU）负责接收输入数据，进行格式转换和初步的数据清洗。
由于 AI 处理器通常是为特定任务优化的硬件，其处理能力与 CPU 有很大不同，
因此需要对输入数据进行适配，以确保数据能够适应后续的硬件计算要求。

此外，在这一阶段，主机端还需要对输入进行解析和验证，以确保其合法性和有效性。
这些工作包括检查输入数据的维度、类型，确保数据格式与设备端预期相符等。
在实际应用中，这一阶段的计算量相对较小，但却是整个过程的关键环节，因为如果数据准备不当，
后续计算将无法顺利进行。

2. 数据传输阶段（主机端向设备端传递数据）

数据准备完成后，接下来的步骤是将处理后的数据从主机端传输到设备端（AI 处理器）。
由于 AI 处理器在处理大规模数据时具有极大的并行计算优势，
这一阶段主要是将数据有效地传递到设备端，并确保数据在设备端能够高效地进行计算。
在这一阶段，传输过程的高效性直接影响到整体计算的性能。
如果数据传输时间过长，会影响整个系统的响应时间。
因此，主机端需要选择合适的传输方式，以降低数据传输延迟，确保数据能尽快到达设备端。

3. 核心计算阶段（设备端执行）

核心计算阶段由设备端（AI 处理器）完成，主要任务是根据 Top-k 算子的原理，
利用设备端的硬件特性进行高效的并行计算。在传统的 CPU 环境下，
Top-k 查询算法通常依赖于单线程或少量线程的处理，效率较低。
而在 AI 处理器中，通过硬件的向量化计算指令，可以在多个计算单元上并行执行相同的操作，大大提高计算速度。
因此，设备端的高效计算是整个 Top-k 查询计算流程的核心所在。


综上所述，通过主机端负责数据准备和管理，设备端负责高效计算，
整个计算流程结合了主机端的灵活性和设备端的计算优势，形成了一种典型的异构计算架构。
通过这种分工，能够充分发挥 AI 处理器的硬件优势，提高 Top-k 算法的计算效率。
这一计算流程不仅适用于大规模数据处理，还能够在深度学习和大数据分析等领域得到广泛应用。
图~\ref{fig:topk}展示了该计算流程的具体实现。
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.3\textwidth]{算子整体流程.png}
    \caption{算子整体流程}
    \label{fig:topk}
    % \note{注：图注的内容不宜放到图题中。}
\end{figure}




\section{主机端任务分析}
    \subsection{接口设计及参数检查}
    拟设计实现的 Top-k 算子输入参数要求如表\ref{tab:input_tab}所示，其中，
    input参数表示输入的张量（tensor），其往往含有多个维度。根据所使用的数据类型，输入张量的元素值可以为整数或浮动小数，
    支持不同的精度（int32 为整数，float32 为浮动小数）。dim 表示待操作的维度，k 表示需要得到的前 k 大/小的值。假设 input 数据总共有 n 个维度，
    并且每个维度的大小为 $\{ x_{0}, x_{1}, \dots, x_{i}, \dots, x_{n-1} \}$，
    则 dim 和 k 所需要满足的数量关系如下：

    \begin{center}
        $0 \leq dim \leq n - 1$
        
        设 dim = i，则： $0 \leq k \leq x_{i}$
    \end{center}
    对于largest，其为bool类型，为true时表示取最大的k个值，为false时，取最小的k个值。
    对于sorted，其为bool类型，为true时表示结果需要排序，为false时，不需要将结果进行排序。
    \begin{table}
        \centering
        \caption{输入参数表}
        \label{tab:input_tab}
        \begin{tabular}{cll} % 注意这里是 'cll' 表示三列，第二列和第三列都对齐左侧
          \toprule
          参数名称   & 数据类型                                       & 描述                          \\
          \midrule
          input & int32/float32 & 输入tensor，可以是任意维度                      \\
          dim & int32   & 表示对第dim维度进行操作            \\
          k   & int32   & 表示取排行前k的数据              \\
          largest & bool   & 默认为true,控制取最大还是最小的值            \\
          sorted & bool   & 默认为false，控制是否需要排序            \\
          
          \bottomrule
        \end{tabular}
    \end{table}

    输出参数表如表\ref{tab:output_tab}所示。其中，
    output是最终的输出 tensor，包含通过 Top-k 查询计算得到的Top-k 大/小值。其数据类型可以是 int32 或 float32，具体取决于输入数据的类型以及计算要求。
    index是与 output 对应的下标。它指示从输入数据的第dim维度的哪个位置获取的 Top-k 元素。
    这在需要返回结果的源数据位置时非常有用，尤其是在需要追踪或处理原始数据时。
    \begin{table}
        \centering
        \caption{输出参数表}
        \label{tab:output_tab}
        \begin{tabular}{cll} % 注意这里是 'cll' 表示三列，第二列和第三列都对齐左侧
          \toprule
          参数名称   & 数据类型                                       & 描述                          \\
          \midrule
          output & /int32/float32 & 输出tensor                 \\
          index   & int32/uint32   & 输出数据在排序维度对应的下标              \\
          \bottomrule
        \end{tabular}
    \end{table}

    \subsection{数据处理}
    %数据的预处理和后处理，阐述数据从多维tensor转换为2维tensor
    %以及调用transpose的必要性
    \paragraph{设备端数据摆布方式分析}
    

    Top - K需要支持多维度数据，可以表示如下：\(\text{dim0}\)，\(\text{dim1}\)，\(\text{dim2}\)，
    \(\text{dim3}\)。由左到右表示维度从高到低，按照\(\text{dim}\)可以将四个维度转化为：
    \(\text{left}\)，\(\text{dim}\)，\(\text{right}\)，\(\text{left}\)为最高维度，
    \(\text{dim}\)为中间维度。当\(\text{dim} = 3\)时表示对\(\text{dim3}\)维度进行Top - K查询
    ，此时\(\text{right} = 1\)，\(\text{left} = \text{dim0}×\text{dim1}×\text{dim2}\)。
    当\(\text{dim} = 0\)时，表示对\(\text{dim0}\)求Top - K，则对应的\(\text{left}\)和
    \(\text{right}\)分别为：\(1\)，\(\text{dim1}×\text{dim2}×\text{dim3}\)。
    
    综上所述可以将任意维度的数据抽象成一个三维张量，
    其形状为\(\text{left}\)，\(\text{dim}\)，\(\text{right}\)，其中，\(\text{dim}\)是
    待操作维度。但是当\(\text{right}≠1\)时，待
    操作维度不在最低维，这意味进行数据I/O时，将有可能浪费有限的带宽。因此，在
    这种情况下需要针对数据后面两个维度进行转置（transpose）操作。此时张量的形
    状为（\(\text{left}\)，\(\text{right}\)，\(\text{dim}\)），进一步的
    ，对于Top - k算子而言，其输入的形状可以抽象为（\(\text{left\_right}\)，\(\text{dim}\)），
    其中\(\text{left\_right}=\text{left}×\text{right}\)。当Top - k任务完成之后，输出的形
    状将为（\(\text{left\_right}\)，\(\text{k}\)），此时需要对结果再次进行转置操作，其输出形状
    为（\(\text{left}\)，\(\text{k}\)，\(\text{right}\)），
    作为最终Top - k算子的最终结果。其形状的转变流程如图~\ref{fig:input_shape}
    
    \begin{figure}[ht]
        \centering
        \includegraphics[scale = 0.4]{input_shape.png}
        \caption{}
        \label{fig:input_shape}
        % \note{注：图注的内容不宜放到图题中。}
    \end{figure}
    
    
    \subsection{核函数选取及配置}
    %阐述根据不同规模的输入对kernel函数选取的重要性。
    %阐述各个kernel函数的任务规模配置。
        \paragraph{radix-select任务类型}
            需注意的是，radix-selct设备端的并行方案需要多次启动kernel函数，并且需要多核协同完成任务，
            因此每次发起的kernel的任务类型为UnionX。而具体需要多少个core，则根据当前的数据规模来计算得到。
    




\section{Top-k并行算法设计及实现}
    


\subsection{小k场景下的radix-select的并行设计及实现}
基数选择（radix-select）是基数排序的一种应用，用于在一组数据中找到具有特定排名的元素。
其算法过程与基数排序算法相似，
但与之不同的是，其在迭代的过程中，RadixSelect仅对包含第 k 大元素的数进行基数排序，达到减少问题规模的效果。
在radix-select top - \(K\)算法中，一个数位（digit）对应着一个元素二进制表示中
的一组连续的\(b\)位。该算法从最高有效数位（most significant digit）到最低有效
数位（least significant digit）处理一个元素，每次迭代处理一个数位。
对于一个由\(r\)位组成的元素，需要进行\(\lceil\frac{r}{b}\rceil\)次迭代。每次迭代主要包含四步，
其伪代码见算法~\ref{alg:Counting}。

\begin{algorithm}
    \SetAlgoLined
    \KwIn{Array $D$ with $n$ entries, integer $k \leq n$}
    \KwOut{array R is the Top-k elements}
    $Bucket \leftarrow$ init $0$ \tcp{size is $2^{digit}$}\\ 
    \underline{HISTOGRAM - KEYS}\\
    \For{$j \leftarrow 0$ to $N - 1$}{
      $Bucket[D[j]] \leftarrow Bucket[D[j]] + 1$
    }
    \underline{SCAN - BUCKETS}\\
    $Sum \leftarrow 0$\\
    \For{$i \leftarrow 0$ to $2^r - 1$}{
      $Val \leftarrow Bucket[i]$ \\
      $Bucket[i] \leftarrow Sum$ \\
      $Sum \leftarrow Sum + Val$ \\
    }
    \underline{FIND TARGET BUCKET}\\
    \For{$i \leftarrow 0$ to $2^r - 1$}{
        \If{Bucket[i] \ge k}{\\
            $POS \leftarrow Bucket[i]$\\ 
            break;\\
        }\\
    }
    \underline{FILTER}\\
    \For{$j \leftarrow 0$ to $N - 1$}{
        If{ D[j] \ge POS}{
            continue;
          }\\

        
    $A \leftarrow Bucket[D[j]]$ \\

      $R[A] \leftarrow K[j]$ \\

      $Bucket[D[j]] \leftarrow A + 1$\\
    }
    \caption{Counting - Sort Algorithm}
    \label{alg:Counting}
  \end{algorithm}
  

  \paragraph{步骤详解}

 ### 1. 初始化桶

  首先，需要初始化一个名为\(Bucket\)的数组，其大小设置为\(2^{digit}\)，并且将数组中的所有元素初始化为\(0\)。其中digit为读取数据的位数，这个\(Bucket\)数组的主要作用是用于统计数组\(D\)中每个元素出现的次数。
  
  ### 2. 构建直方图

 在此阶段，会遍历数组\(D\)中的每一个元素\(D[j]\)，统计\(D[j]\)中元素出现的个数，记录在\(Bucket\)中。
  
 ### 3. 扫描桶

 计算出每个桶的累积和，而这个累积和对于确定每个元素在排序后的位置起到了关键作用。

  ### 4. 找到目标桶

再次遍历\(Bucket\)数组，目的是找到第一个满足\(Bucket[i] \geq k\)的桶。

  ### 5. 过滤

  在此阶段，会再次遍历数组\(D\)，目的是将数组\(D\)中的前\(k\)大元素挑选出来，
  并放入结果数组\(R\)中。




  \subsection{大k场景下的radix-slect的并行设计及实现}
  国产 AI 处理器具备多核心架构且支持并行运算，在处理维度为\((A,B)\)的输入数据时，算法的并行度显著受制于\(A\)与\(B\)的维度特性。
  于特定情境下，当\(A\)取值较小（低于\(10\)）而\(B\)取值较大（超出\(100\)万）时，单核处理方式会引发严峻的负载均衡困境。具体表现为：其一，凭借\(A\)维度所构建的并行度匮乏，致使部分核心处于闲置状态，无法充分发挥其计算效能；其二，由于\(B\)的规模庞大，被分配任务的核心将持续处于工作负载之下，难以实现高效的资源分配与利用。
  鉴于上述挑战，本研究精心设计并成功实现了适用于多核处理的 radix - select Top - k 算子。该算子旨在通过多核协同机制，有效缓解因维度不均衡所导致的负载失衡问题，充分挖掘国产 AI 处理器多核心架构的并行计算潜力。
  此外，参数\(k\)的取值规模与算子的具体实现策略紧密关联。当\(k\)较大（例如超越片上内存 NRAM 的存储容量）时，不可避免地需将临时输出数据暂存于片外空间 GDR。然而，如前文所阐述，GDR 作为存储层级中带宽最低的部分，其数据传输速率严重制约程序的整体性能表现。
  故而，本研究进一步依据\(k\)的不同取值范围，系统性地设计并实现了具有针对性的 Top - k 算子。
  后续将对相关设计与实现细节予以详尽阐释。
  
%   \paragraph{}
  






%   \paragraph{}
  前面所介绍的各个实现方案，充分利用了“小k”场景下的一个重要特性——NRAM空间能够存放完整的临时输出。
  而由于NRAM的空间十分有限，因此k的范围不能够太大，否则将会导致程序崩溃。
  因此，此时考虑将临时输出存储在GDR空间上。
  
  回顾radix-select Top-k的串行算法，由于其所有阶段都存在循环依赖关系，所以不能直接进行并行化（或向量化）。
  例如，如果试图对"构建直方图"（HISTOGRAM - KEYS）的迭代进行并行处理，可能会有多个处理器同时尝试
  对同一个桶（bucket）进行递增操作，产生资源竞争。而如果锁定桶，当有许多键具有相同数位时，
  桶将成为串行瓶颈，将会极大地降低性能。基于以上的分析，可以通过为每个处理器分配一组独立的桶（本地桶），
进而在不需要对桶进行锁定的情况下实现算法并行化:
即每个处理器负责其自己的局部数据（\(\frac{N}{P}\)子集），
并将它们列入自己的本地桶集合中。
此时，可以将所有的桶看作是一个矩阵\(Buckets[i, j]\)，如下图~\ref{fig:process_bucket}。

\begin{figure}[ht]
    \centering
    \includegraphics[scale = 0.6]{process_bucket.png}
    \caption{}
    \label{fig:process_bucket}
    % \note{注：图注的内容不宜放到图题中。}
\end{figure}

其中 $i$ 是处理器数，$j$ 是本地桶的桶数。在每个处理器都拥有自己的桶之后，
每个处理器在进行基数选择的
第一阶段，第三阶段和第四阶段（HISTOGRAMKEYS ， FIND TARGET BUCKET和 FILTER）时，
都在自己的局部数据上进行工作，从而解除所有依赖项。
但需要注意到，为了保证结果的正确性，第三阶段（ SCAN-BUCKETS ）将必须进行修改。因为如果
每个处理器仅扫描自己的本地桶，将仅仅只能得到局部数据的Top-k结果，导致结果错误。而通过分析我们发现，
$Buckets[i][j]$代表在进行SCAN-BUCKETS处理后，$A$中元素最终在结果$R$中的偏移位置，
具体关系见下图~\ref{fig:digits}。
\begin{figure}[ht]
    \centering
    \includegraphics[scale = 0.6]{process_digits.png}
    \caption{并行radix-select的扫描步骤}
    \label{fig:digits}
    % \note{注：图注的内容不宜放到图题中。}
\end{figure}

假如该算法用 4 个处理器和 4 个桶来对 0 - 3 的值进行排序。偏移量是通过扫描桶来计算的。
扫描之后，每个处理器在具有特定值的键的最终输出中都有一个起始位置。
例如，处理器 3 将把值为 “0” 的键从输出中的第 5 个位置开始放置，把值为 “1” 的键从第 14 个位置开始放置，如偏移量所示。

所以需要将矩阵\(Buckets[i, j]\)在列方向上以及行方向上进行扫描操作，以汇总全局信息，
其数学公式见~\ref{equ:buckets}
\begin{equation}
    \text{ Buckets}[i, j]' = \sum_{k = 0}^{p - 1} \sum_{m = 0}^{j - 1} \text{ Buckets}[k, m] + \sum_{k = 0}^{i - 1} \text{ Buckets}[k, j]
    \label{equ:buckets}
\end{equation}
也就是说，偏移量是所有处理器中小于 $j$ 的数位总数，再加上小于 $i$ 的处理器中数位等于 $j$ 的数量。
这个总和可以通过将$Buckets$矩阵按列优先顺序展开，
然后对展开后的矩阵执行 “SCAN - BUCKETS” 操作来进行计算。同时，找到目标桶这一阶段，Bucket数组中，仅第一行中
的数据代表着全局的前缀信息，因此仅需要Core0进行这一阶段的主要任务即可。
%   在并行实现中，划分操作分以下几步：
%   \begin{enumerate}
%       \item 使用多个处理器计算标记数组\(B\)，每个处理器负责数组的一部分。
%       \item 使用并行扫描技术计算前缀和\(P\)，其时间复杂度为\(O(\log n)\)。
%       \item 根据前缀和数组\(P\)，每个处理器独立将元素从输入数组\(A\)复制到目标数组\(L\)或\(R\)。
%   \end{enumerate}
在并行实现中，主要工作流程分为以下几步：
\begin{enumerate}
    \item 对于输入数据（二维Tensor），将数据按照行进行切分，每个Cluster负责数据的若干行，
    而后每个Cluster对所分配的行依次处理。
    \item 对于Cluster正在处理的某一行数据而言，采用多核进行计算。因此需要将整行数据平均分到各个处理器上。
    \item 在单核上，由于片上空间有限，因此需要将局部数据进一步划分成repeat段，循环依次load到片上进行操作，统计出局部前缀和数组\(P\_local\)。
    \item 根据\(P\_local\)，按照前文分析计算出全局前缀和数组\(P\)。
    \item 根据P，让Core0执行算法的第四阶段（FIND\ TARGET\ BUCKET），找到k\_bins。
    \item 根据k\_bin和P，执行过滤操作。将k\_bin之前的数据复制到输出所在的内存，并记录好offset。而后将k\_bin中的数据，作为下一次迭代的输入。
\end{enumerate}

\paragraph{并行实现}
以下结合国产AI处理器的内存层次和指令，对算法的各个主要阶段进行阐述：
\subparagraph{初始化桶}

首先，需要初始化一个名为\(Bucket\)的数组，其大小设置为\(2^{digit} \times processor\)，
并且将数组中的所有元素初始化为\(0\)。其中digit为读取数据的位数，processor为具体任务类型
所对应的处理器数目，这个\(Bucket\)数组的主要作用是用于统计数组\(D\)中每个元素出现的次数。
每个处理器管理的数组大小为\(2^{digit}\)。
\subparagraph{构建直方图}

为了节省内存空间，不定义数组\(D\)所需要的空间，而是在此阶段使用bang\_band\_cycle指令，
根据输入和循环所处的遍数计算出\(D\)，
而后使用bang\_histogram统计当前统计\(D[j]\)中元素出现的个数，记录在\(Bucket\_local\)中。
在处理器处理完所有的局部数据后，将\(Bucket\_local\)复制到片外内存\(Bucket\)中。

\subparagraph{扫描桶}

计算出每个桶的累积和，。

\subparagraph{找到目标桶}

再次遍历\(Bucket\)数组，目的是找到第一个满足\(Bucket[i] \geq k\)的桶。
在此阶段，主要使用bang\_gt\_cycle和bang\_filter指令来确定目标桶的下标。

\subparagraph{过滤}

在此阶段，会再次遍历输入数组\(A\)求得\(D\)，根据目标桶的下标得到digit\_num，
而后使用bang\_gt和bang\_filter指令将A中的数据筛选出来，
再根据Bucket中的偏移值将数据复制到指定位置。
另外将等于digit\_num的数据筛选出来放到数组\(R\)中。


\subsection{基数选择对数据类型与数值正负性的适应性分析}


基数选择作为一种重要的排序类算法，其在不同数据类型以及数值正负性处理上具有特定的要求与表现，以下将对此展开深入探讨。

\paragraph{数据类型要求}

% 通过上面的分析可以得出两点一致性的结论，进而使得问题能够更加聚焦，即：
% 1.对于整型和浮点型，虽然数据的存储方式不同，但其从0到30位（除符号位）对数字大小的重要性依次递增。
% 2.当数据中同时存在正负数时，整型和浮点型数据会因为符号位而产生负数大于正数的问题。
% 因此，为了确保排序结果的准确性与有效性，需要去解决这一问题。
基数选择在整数领域应用广泛且具有不同处理方式。对于固定长度的无符号整数，
如常见的 32 位无符号整数数组，可依据其二进制表示直接实施基数选择。
选择过程可选择从最高有效位（MSB）至最低有效位（LSB），
按位依次对整数进行选择操作。例如，在对一组无符号 32 位整数选择时，
先依据最高位的值将整数分配至不同桶中，完成一轮选择后，再依据次低位进行同样操作，
直至处理完所有位，最终选择出来目标数。但对于有符号整数,浮点数，由于符号位的存在，
会导致负数比正数更大的非预期效果。因此需要针对不同的数据类型以及数据的正负性进行
进一步的分析。

### （一）整数类型

针对整数类型数据，基数选择可基于其特定二进制表示形式开展。

在遵循计算机中常用的二进制补码表示的整数表示中，以\(int32\)数据类型为例，
整数在内存中的存储分为以下几部分：

符号位（\(Sign\ bit\)）：表示整数的正负，\(0\)表示正，\(1\)表示负。
对于\(int32\)类型来说，其最高位（第\(31\)位）就是符号位。

数值部分（\(Value\ part\)）：剩余的\(31\)位（第\(0\)位至第\(30\)位）
用于表示整数的绝对值大小（在正数情况下，其对应的二进制数值就是实际的数值；
在负数情况下，这\(31\)位表示的是该负数绝对值的补码形式）。

具体而言，在正数时，例如十进制的\(5\)用二进制表示就是\(00000000\ 00000000\ 00000000\ 00000101\)，
其最高位符号位为\(0\)，后面\(31\)位就是实际数值\(5\)的二进制表示。

而对于负数，比如十进制的\(-5\)，先取其绝对值\(5\)的二进制表示\(00000000\ 00000000\ 00000000\ 00000101\)
，然后进行补码运算（按位取反再加\(1\)），得到\(11111111\ 11111111\ 11111111\ 11111011\)，此时最高位
符号位为\(1\)，表示这是一个负数，后面\(31\)位按照补码规则来表示其绝对值大小，通过这样的形式实现了在计算机
内存中用\(32\)位对\(int32\)类型整数（包含正负）的存储，而基数选择算法在处理\(int32\)类型整数时，若直接
按照无符号整数的逻辑进行运算，将会产生负整数大于非负整数的现象。其根本原因就是因为符号位的存在以及负整型数据的
编码规则，整型数据的各个比特位的重要性并不是从最低位依次递增的，因此需要进行预处理操作。

为了更好的说明问题，且基数选择算法与基数排序算法具有很强的一致性，下文以基数排序来进行举例，说明问题的现象以及对应的解决方案。
设原始数据为data0，具体数据为[-2, 1, 0,  -3, 3, -1, 2]  7个int32数据。其表示见下图：

\begin{figure}[ht]
    \centering
    \includegraphics[scale = 0.5]{data1_int32.png}
    \caption{}
    \label{fig:data1_int32}
    % \note{注：图注的内容不宜放到图题中。}
\end{figure}


原始数据经过基数排序后的 data1为：

\begin{figure}[ht]
    \centering
    \includegraphics[scale = 0.5]{data1_int32.png}
    \caption{}
    \label{fig:data1_int32}
    % \note{注：图注的内容不宜放到图题中。}
\end{figure}


经过基数排序后，结果与预期不符：结果的排布方式为正数为非降序，负数为非降序，且负数在正数后。
对于这种问题目前的解决方案有两种：

a.当升序排序时，预先得到负数和非负数的总个数，
然后据此将正数和负数写回的index进行偏移。
b.对数据进行预处理，对符号位进行变换，在最后再将变换后的数据进行还原。

因为方案b可以直接使用位操作指令，性能更快，且实现更加简便，因此这里使用了方案b进行实现。
具体的实现方案如下：
\begin{description}
\item[预处理]：
因为期望非负数在负数之后，所以直接将所有数的符号位进行取反操作，
即直接将输入数组中的各个元素与0x80000000进行位异或。

\item[后处理]：恢复原来的数据，基数排序完成后index是符合期望的，
现在需要做的是将原始数据revert回来；因此将输出数据再次与0x80000000进行位异或。
\end{description}

上述步骤主要使用到的平台指令及具体作用如下：

1.按bit取反： bang\_bxor\_scalar 和 bang\_mlu

通过上述处理之后，数据将会正常显示：

\begin{figure}[ht]
    \centering
    \includegraphics[scale = 0.5]{res_int32.png}
    \caption{}
    \label{fig:res_int32}
    % \note{注：图注的内容不宜放到图题中。}
\end{figure}





### （二）浮点数类型

针对浮点数类型数据，基数选择可基于其特定二进制表示形式开展。
在遵循 IEEE 754 标准的浮点数表示中，以float32数据类型为例，
浮点数在内存中的存储分为以下三部分：

符号位（Sign bit）：表示浮点数的正负，0 表示正，1 表示负。
指数部分（Exponent）：表示浮点数的指数，用偏移量编码（偏移量也称为偏置，为127）。
尾数部分（Mantissa）：表示浮点数的有效数字，通常采用归一化表示（即小数点左边默认为 1）。


\begin{figure}[ht]
    \centering
    \includegraphics[scale = 0.3]{float32.png}
    \caption{}
    \label{fig:float32}
    % \note{注：图注的内容不宜放到图题中。}
\end{figure}
这种结构设计使得浮点数在数值表示上具有独特的规律，虽然不同于整型数据，但是
其中从 0 到 30 位（除符号位）对数字大小的重要性仍然是依次递增。
同样的，由于符号位的存在，其存在与有符号整数相似的问题（但不完全相同）。
以float数据类型为例，half类型同理。
设原始数据为data0，具体数据为[-2, 1, 0,  -3, 3, -1, 2] 7个float32数据，对其进行
为了更好的说明问题，此处我们同样以基数排序进行问题的说明。



\begin{figure}[ht]
    \centering
    \includegraphics[scale = 0.5]{data0_float32.png}
    \caption{}
    \label{fig:data0}
    % \note{注：图注的内容不宜放到图题中。}
\end{figure}


原始数据经过基数排序后的 data1为：

\begin{figure}[ht]
    \centering
    \includegraphics[scale = 0.5]{data1_float32.png}
    \caption{}
    \label{fig:data1}
    % \note{注：图注的内容不宜放到图题中。}
\end{figure}


经过基数排序后，结果与预期不符：结果的排布方式为正数为非降序，负数为非升序，且负数在正数后。
对于这种问题目前的解决方案有两种：

a.当升序排序时，预先得到负数和非负数的总个数，
然后据此将正数和负数写回的index进行偏移，同时由于负数为降序排序，
所以将data1中负数内部进行reverse。 

b.对数据进行预处理，对符号位进行变换，在最后再将变换后的数据进行还原。

因为方案b可以直接使用位操作指令，性能更快，且实现更加简便，因此这里使用了方案b进行实现。
具体的实现方案如下：
\begin{description}
\item[预处理]：
因为期望非负数在负数之后，所以考虑将所有数的符号位进行取反操作；
同时期望负数内部为升序排列，所以考虑将负数的非符号位进行取反操作；
即：对正数进行符号位取反，对负数全部bit位进行取反，即非负数数与 0x80000000进行位异或操作, 
负数 与 0xffffffff 进行位异或操作; （任何数与0异或保持不变，与1异或会取反）

\item[后处理]：恢复原来的数据，基数排序完成后index是符合期望的，
现在需要做的是将原始数据revert回来；即将对正数进行符号位取反，
对负数全部bit位进行取反，得到最终结果RES。
\end{description}


通过上述处理之后，数据将会正常显示：

\begin{figure}[ht]
    \centering
    \includegraphics[scale = 0.5]{res_float32.png}
    \caption{}
    \label{fig:res_int32}
    % \note{注：图注的内容不宜放到图题中。}
\end{figure}


上述步骤主要使用到的平台指令及具体作用如下：

a.用来得到区分非负数和负数的mask： bang\_band\_scalar 和 bang\_eq\_scalar

b.按bit取反： bang\_bxor\_scalar 和 bang\_mlu

\paragraph{基数选择对最大/最小值的分析}
基于前文针对正负性所展开的讨论，在实施 radix - select 算法的进程中，若预先对数据予以预处理，则 radix - select 函数的功能性能够得到优化，进而无需对数值的正负特性以及数据类型予以过度的关切。鉴于数据预处理所具有的关键意义，本文深入探究了借助数据预处理来达成 radix - select 函数与最大值或最小值相解耦的可行性。通过深入且细致的分析后可知，恰似处理正负性问题的情形，凭借数据预处理的策略，能够将“Top - k 大”的问题有效地转换为“Top - k 小”的问题，从而显著地削减 radix - select 函数在实现过程中的复杂程度。

### （一）整数类型
为了更为清晰地阐释相关问题，并且鉴于基数选择算法与基数排序算法之间存在着高度的一致性，下文将以基数排序为例，阐述问题的现象及其对应的解决方案。

设定原始数据为 data0，其具体数据为 [-2, 1, 0, -3, 3, -1, 2] 这 7 个 int32 类型的数据。倘若在此情形下需要获取前 Top - k 大的元素，那么我们能够通过对原数据进行适当的更改，从而将问题转化为“获取前 Top - k 小的元素”。

依据上文的分析，若直接对 data0 执行基数排序操作，将会得到 [0, 1, 2, 3, -3, -2, -1] 这样的排序结果。考虑到我们实际所期望的结果是降序输出，就负数与正数的整体相对位置而言，其输出结果是与预期相符的，故而数据的符号位无需进行变更。然而，针对负数内部的排序结果以及正数内部的排序结果来讲，均与预期的降序结果相互背离。因此，需要对所有数据的非符号位实施取反操作。通过上述一系列的操作处理，我们能够简洁高效地将原始问题进行转换。

### （二）浮点数类型
为了更为有效地说明问题，鉴于基数选择算法与基数排序算法之间的紧密关联性，以下将以基数排序作为示例，用以说明问题的现象及其对应的解决方案。

设定原始数据为 data0，其具体数据为 [-2.0, 1.0, 0.0, -3.0, 3.0, -1.0, 2.0] 这 7 个 float32 类型的数据。若在当前情形下需要获取前 Top - k 大的元素，那么我们可通过对原数据进行调整，将问题转化为“获取前 Top - k 小的元素”。

依据前文的分析，若直接对 data0 执行基数排序，将会得到 [0.0, 1.0, 2.0, 3.0, -1.0, -2.0, -3.0] 这样的结果。考虑到我们所需求的结果是降序输出，对于负数而言，无论是负数内部的排序结果，还是负数相对于正数的排序结果，均与预期相契合，因此数据的符号位保持不变且负数无需进行任何改动。而对于非负数部分，由于所期望的输出应当是数值越大其相对顺序越小，所以需要对非负数的非符号位进行取反操作。通过上述的操作流程，我们能够便捷地将原始问题予以转换。 













\section{本章小结}
